#+options: ^:nil toc:nil

* org
#+begin_src elisp
(org-export-define-derived-backend 'stasis-md 'md
  :translate-alist
  '((template . stasis-md-template)
    (link . stasis-md-link)))

(defun stasis-md-template (contents info)
  (concat
   (format "Title: %s\n" (car (plist-get info :title)))
   (format "Date: %s\n" (car (plist-get info :date)))
   "\n\n"
   contents))

(defun stasis-md-link (link desc info)
  (let ((type (org-element-property :type link)))
    (cond
     ((string= type "file")
      (let* ((path (org-element-property :path link))
             (new-path (replace-regexp-in-string "^\\./resources/public" "" path))
             (new-link (org-element-copy link)))
        (org-element-put-property new-link :path new-path)
        (org-md-link new-link desc info)))
     (t (org-md-link link desc info)))))

(defun my/stasis-export ()
  "Export each top-level heading of the current Org file to its own file."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "^\\* " nil t)
      (org-narrow-to-subtree)
      (unless (org-in-commented-heading-p)
        (let* ((file (org-export-output-file-name ".md" 'subtree))
               (dir (and file (file-name-directory file))))
          (when file
            (message "Exporting %s..." file)
            (when (and dir (not (file-directory-p dir)))
              (make-directory dir 'parents))
            (org-export-to-file 'stasis-md file nil 'subtree))))
      (widen))))

(defun my/stasis-new (title)
  "Create a new blog post heading with properties."
  (interactive "sTitle: ")
  (let* ((random-id (mapconcat (lambda (_) (format "%x" (random 16))) (make-list 6 nil) ""))
         (date (format-time-string "%Y-%m-%d"))
         (year (format-time-string "%Y"))
         (file-name (format "generated/contents/blog/%s/%s" year random-id)))
    (goto-char (point-max))
    (insert (format "\n* %s\n:properties:\n:export_file_name: %s\n:export_date: %s\n:end:\n\n"
                    title file-name date))))
#+end_src

#+RESULTS:
:results:
my/stasis-new
:end:

* Conao3 Notes
:properties:
:export_file_name: generated/contents/index.md
:export_date: 2024-12-21
:end:

** Links
- GitHub :: https://github.com/conao3
- X(Twitter) :: https://x.com/conao_3
- 技術書典 :: https://techbookfest.org/organization/b48gui73eygdZDs02kqB1C

* Hello Stasis
:properties:
:export_file_name: generated/contents/blog/2024/5a7fcc.md
:export_date: 2024-12-21
:end:

私は conao3.com を持っていて、どうせ何回ブログを作っても飽きるので初めからサブドメインで用意するようにしています。
今までのブログはこんな感じ。

- https://conao3.com :: 2020/05~ hugo製
- https://a.conao3.com :: 2023/03~ astro製
- https://s.conao3.com :: 2024/12~ stasis製

このブログは[[https://github.com/magnars/stasis][stasis]]から生成されています。
stasisはClojureの静的ブログ生成ライブラリで、主張がほとんどない薄いフレームワークです。

descriptionには「Some Clojure functions for creating static websites.」とあります。
その説明通り、提供されているのは単なる関数なので、それを自分で組み合わせてオレオレフレームワークを作ろうぜという世界観です。

ソースは[[https://github.com/conao3/blog-stasis-src][conao3/blog-stasis-src]]においてあります。
ひとまずこんなところで。

* ClojureでEcho Server
:properties:
:export_file_name: generated/contents/blog/2024/4d880f.md
:export_date: 2024-12-23
:end:

ClojureでTCPソケットを使ったプログラムを書きたくなりました。
TCPソケットを使おうと思ったら書くのがEcho Serverですね。書きましょう。

ライブラリなしで書くときはとりあえずcoreのドキュメントを参照します。
https://clojure.github.io/clojure/index.html

しかし、ソケット通信のためのAPIは用意されてないので、javaのドキュメントを参照します。
Clojureが利用しているJDKのバージョンは以下で調べることができます

#+begin_src clojure
(System/getProperty "java.version")
;;=> "21.0.5
#+end_src

JDK21のドキュメントはこちらです。
- https://docs.oracle.com/javase/jp/21/index.html
- https://docs.oracle.com/javase/jp/21/docs/api/index.html

=java.net= を使うことで実装できそうです。

** 調査
まずサーバー側のソケットを作り、 =accept= で待ち受けます。
=accept= は通信要求が来るまでブロッキングされます。

#+begin_src clojure
(def server-socket (java.net.ServerSocket. 15390))
;;=> #'user/server-socket

(def client-socket (. server-socket accept))
;;=> #'user/client-socket
#+end_src

なお、クライアントは =telnet= で試すことができます。
=telnet= は =C-]= を押すと通信を止めることができます。

#+begin_src sh
$ telnet localhost 15390
Trying ::1...
Connected to localhost.
Escape character is '^]'.
#+end_src

サーバー側に戻ります。
=client-socket= を得ることができたら、 =io/reader= と =io/writer= により、ioを得ることができます。
#+begin_src clojure
(def input-stream (io/reader client-socket))
;;=> #'user/input-stream

(def output-stream (io/writer client-socket))
;;=> #'user/output-stream
#+end_src

=io/reader= の返り値のため、 =readLine= などを利用することができます。
#+begin_src clojure
(. input-stream readLine)
;;=> "asdf"
#+end_src

=readLine= は ="\n"= が入力されるまでブロッキングします。

** 実装
調査を受けて、実装はこちらです。

#+begin_src clojure
(ns echo-server.core
  (:require
   [clojure.java.io :as io])
  (:import
   [java.net ServerSocket]
   [java.io BufferedReader BufferedWriter])
  (:gen-class))

(defn handle-client [client-socket]
  (let [input-stream ^BufferedReader (io/reader client-socket)
        output-stream ^BufferedWriter (io/writer client-socket)]
    (loop []
      (let [inpt (. input-stream readLine)]
        (println "Received: " inpt)
        (when (and inpt (not= "" inpt))
          (. output-stream write (str inpt "\n"))
          (. output-stream flush))
        (when-not (nil? inpt)         ; nil indicates EOF
          (recur))))))

(defn start-server []
  (println "Listening localhost:15390")
  (let [server-socket (ServerSocket. 15390)]
    (loop []
      (let [client-socket (. server-socket accept)]
        (println "Connection Accepted")
        (handle-client client-socket))
      (recur))))
#+end_src

もうちょっとClojureらしく書かせて欲しいという感情はありますが、とりあえずこれでできました。

* COMMENT Nix with Commonlisp
:properties:
:export_file_name: generated/contents/blog/2024/fa34f6
:export_date: 2024-12-27
:end:

NixでCommonlispプロジェクトを管理する。
taniさんがテンプレを用意してくれているので、それを使わせてもらう。

#+begin_src elisp
(setq inferior-lisp-program "nix develop --command sbcl")
#+end_src

#+begin_src common-lisp
(:source-registry
 (:tree (:home "dev/repos/cl-paip"))
 :inherit-configuration)
#+end_src

load
#+begin_src common-lisp
(asdf:load-system :paip)
#+end_src

test
#+begin_src common-lisp
(asdf:test-system :paip)
#+end_src

* 日本語レポートから始めるorg-modeとEmacs
:properties:
:export_file_name: generated/contents/blog/2025/f84aea
:export_date: 2025-12-02
:end:

この記事は[[https://qiita.com/advent-calendar/2025/emacs][Emacs Advent Calendar 2025]]の4日目の記事です。

[[https://orgmode.org/][org-mode]]は言わずと知れたEmacsのキラーフィーチャーですが、Emacsの学習曲線もさることながら、org-modeの学習曲線も同様に急峻であるため入門したくても踏み切れないという初心者の方がたくさん居るという声を聞きます。
しかし、タイトルにもありますが、日本語レポートから始めるorg-modeでゆるやかにorg-mode、しいてはEmacsに入門するのは私がとてもおすすめしている入門経路で、実は私もこの経路でorg-modeとEmacsに入門しています。

ぜひ怖がらずに入門してみましょう。

** 日本語レポートの題材
なんでも良いのですが、[[https://tcs.c.titech.ac.jp/csbook/c_lang/chap1.html][東工大のC言語入門]]を見つけたのでこれを使わせてもらうことにします。

** Emacsの起動とファイルの準備
Emacsをインストールして起動してください。
Nixをインストールしている方は以下のコマンドでEmacsがインストールされている環境に入ることができます。

#+begin_src shell
nix shell nixpkgs#emacs
#+end_src

その後、 =emacs= で起動できます。

#+begin_src shell
emacs
#+end_src

[[./resources/public/img/9ad97367-e768-4a84-8d87-b6c15c23801e.png]]

=C-x C-f (find-file)= を実行してファイルを開きます。存在しないパスを指定すると空のファイルとして開くことができます。

[[./resources/public/img/c7e82a66-58d6-4e62-8145-705ad1fdeece.png]]

ここでもしフォルダが存在していない場合は以下のようなメッセージが表示されます。

> Use M-x make-directory RET RET to create the directory and its parents

この通りに実行してフォルダを作ることもできますし、保存時にフォルダを作るか尋ねられるので、そこでyと答えてもOKです。

[[./resources/public/img/13c9c8c4-b7d3-4fdd-941f-1666826bcc11.png]]

[[./resources/public/img/0fff68f2-5564-4403-8c5c-74e16fc015fe.png]]

** org-modeの文法
[[https://orgmode.org/features.html][features]]のページがざっと全体像になっています。
レポートを書くという目的ではheadingの作り方といくつかの文字装飾の方法を学んでおくと良いでしょう。
markdownとの対応で記述します。

*** headingの作り方
markdownでは =#= を使いますが、org-modeでは =*= を利用します。 =M-RET= で挿入することができ、heading上にポインタがある状態で =M-←= や =M-→= でレベルの変更ができます。

h1は =*= 、h2では =**= というように重ねて深いレベルを表現するところは同じです。

なおmarkdownと同じく、改行は無視され、空行を入れることで段落分けを表現します。
そのため、headingの間は自由な量の空行を入れることができます。

#+begin_src org
,* heading 1
ほんぶん1
,** heading 1.1
ほんぶん1.1
,** heading 1.2
ほんぶん1.2

,* heading 2
,** heading 2.1
,** heading 2.2
#+end_src

*** 文字装飾
(本当はそのまま表示したかったけどレンダリングを止められなかったのでコードブロックで。)

#+begin_src org
| markdown     | org-mode     | rendered   |
|--------------+--------------+------------|
| =`code`=     | ==code==     | =code=     |
| =*emphasis*= | =/emphasis/= | /emphasis/ |
| =**strong**= | =*strong*=   | *strong*   |
| =~~strike~~= | =+strike+=   | +strike+   |
#+end_src

*** リスト
markdownと同じく =-= でリストを作ることができます。
=-= のリスト上にポインタがあるとき、 =M-RET= で追加の =-= を挿入することができます。
headingと同じく、リスト上にポインタを置いた上で =M-←= と =M-→= でリストの深さを変更することができます。

#+begin_src org
- apple
- banana
- orange
  - orange2
#+end_src

- apple
- banana
- orange
  - orange2

*** リンク
markdownでは =[link text](link)= と表現するところ、org-modeでは =[[link][link text]]= と表現します。
逆になっているので注意しましょう。

もしくは =link text= と書いて選択した後、 =C-c C-l (org-insert-link)= を実行することで、対話的にリンクを作ることができます。

[[https://orgmode.org/][org-mode]]へのリンクです。

*** テーブル
テーブルはmarkdownと同じくasciiで表現します。

テーブルヘッダはあってもなくても良く、作る場合は =-= で区切ります。
ただし、この表記を全て自分で整えなくても良く、ある程度書いたら =C-c C-c= を押すことでorg-modeに整えてもらうことができます。

#+begin_src org
| 名前    | 説明         |
|---------+--------------|
| table   | テーブル     |
| caption | キャプション |
#+end_src

| 名前    | 説明         |
|---------+--------------|
| table   | テーブル     |
| caption | キャプション |

*** コードブロック
org-modeでのコードブロックは拡張性があるがゆえにに少し冗長に感じるかもしれません。
markdownでは =``` 言語= と =```= で囲むことによって表現しますが、org-modeでは =#+begin_src 言語= と =#+end_src= で囲うことによって表現します。

#+begin_src org
,#+begin_src python
print("hello")
,#+end_src
#+end_src

#+begin_src python
print("hello")
#+end_src

言語の指定がなく、単にコードブロックとして表現したい場合は =#+begin_example= と =#+end_example= で囲います。

#+begin_src org
,#+begin_example
こーど
ブロック
,#+end_example
#+end_src

#+begin_example
こーど
ブロック
#+end_example

*** 脚注
markdownでは =foo[^foo]= と =[^foo]: fooに対しての脚注= と書きますが、org-modeは =foo[fn::fooに対しての脚注]= と表記します。

こんな感じ[fn::どんな感じ？]になります。

*** メタ設定
org文書に対してタイトルなどを指定することができます。
基本的にはファイルの先頭に書くことが多いです。

#+begin_src org
,#+title: 文書のタイトル
,#+author: conao3
,#+date: 2025-12-02
#+end_src

設定できる項目の一覧は[[https://orgmode.org/manual/Export-Settings.html
][ドキュメント]]にあります。
設定できてもエクスポートに利用する形式でサポートされていないと単に無視されることもあります。

** レポートを書こう
ここまで学んだ文法を元にorg-modeでレポートを書いてみましょう。

#+begin_src org
,#+title: C言語入門01 - プログラミングの準備
,#+author: conao3
,#+date: 2025-12-02

,* 演習問題回答
,** 演習1-1
,#+begin_example
以下のプログラムをコンパイル・実行すると、どのような表示がされるか確認してください。

#include <stdio.h>

int main() {
    printf("2 * 8 = %d\n", 2 * 8);
    printf("36 = %d * %d\n", 3, 12);
    return 0;
}
,#+end_example

回答

,#+begin_example
2 * 8 = 16
36 = 3 * 12
,#+end_example

,** 演習1-2
,#+begin_example
以下のプログラムをコンパイルするとコンパイルエラーが発生します。
コンパイルエラーが発生する理由を考えて、修正方法を考えてください。

#include <stdio.h>

int main() {
    printf("The quick brown fox
            jumps over
            the lazy dog.");
    return 0;
}
,#+end_example

文字列の終端なしに行の終わりになっているため、エラーが発生する。
修正方法としては =\= を行末に置き、行継続していることを表現することでエラーを修正できる。

,#+begin_src C
    printf("The quick brown fox\
            jumps over\
            the lazy dog.");
,#+end_src

,** 演習1-3

,#+begin_example
以下のプログラムと同じ表示をするプログラムをprintf 関数を
1 回しか使わずに記述してください。

ヒント: \n は文字列の途中に書くこともできます。

#include <stdio.h>

int main() {
    printf("%d apples\n", 4);
    printf("%d apples\n", 9);
    printf("%d apples\n", 16);
    return 0;
}
,#+end_example

回答

,#+begin_src C
#include <stdio.h>

int main() {
    printf("%d apples\n%d apples\n%d apples\n", 4, 9, 16);
    return 0;
}
,#+end_src

,#+begin_example
4 apples
9 apples
16 apples
,#+end_example
#+end_src

** エクスポートしてみよう
残念ながらorg-modeの形式では教授は受け取ってくれません。
しかし、org-modeから種々のフォーマットに変換することでその問題を解決することができます。

テキストフォーマットはもちろん、markdownやhtml、man形式やLaTeX形式など様々なフォーマットが[[https://orgmode.org/manual/Exporting.html][org-mode本体によりサポート]]されています。
なお、筆者はこの機能でLaTeXにエクスポートし卒論を書きました。

さらにはコミュニティにより他にも様々なフォーマットへの変換がサポートされています。
エクスポートパッケージは =ox=- を付けることが慣習のため、[[https://melpa.org/#/?q=ox-][MELPAでこのクエリを入れて検索]]すると追加で実に40種ほどのエクスポート先を利用することができます。
その中には私が作成した [[https://zenn.dev/conao3/articles/ox-zenn-usage][ox-zenn]] もあります。

今回は簡単にテキストフォーマットのエクスポートを試してみましょう。
org-modeの文書を開いた状態で、 =C-c C-t (org-export-dispatch)= を実行します。

[[./resources/public/img/07531bdc-3d0d-4137-8f18-c297e5d5f2d7.png]]

そうすると現在エクスポート可能な一覧が表示されるので、今回は =t A= と入力してasciiでのテキストフォーマットにエクスポートしてみましょう。その結果がこちらです。

#+begin_example
                  ____________________________________

                   C言語入門01 - プログラミングの準備

                                 conao3
                  ____________________________________


                               2025-12-02


Table of Contents
_________________

1. 演習問題回答
.. 1. 演習1-1
.. 2. 演習1-2
.. 3. 演習1-3


1 演習問題回答
==============

1.1 演習1-1
~~~~~~~~~~~

  ,----
  | 以下のプログラムをコンパイル・実行すると、どのような表示がされるか確認してください。
  | 
  | #include <stdio.h>
  | 
  | int main() {
  |     printf("2 * 8 = %d\n", 2 * 8);
  |     printf("36 = %d * %d\n", 3, 12);
  |     return 0;
  | }
  `----

  回答

  ,----
  | 2 * 8 = 16
  | 36 = 3 * 12
  `----


1.2 演習1-2
~~~~~~~~~~~

  ,----
  | 以下のプログラムをコンパイルするとコンパイルエラーが発生します。
  | コンパイルエラーが発生する理由を考えて、修正方法を考えてください。
  | 
  | #include <stdio.h>
  | 
  | int main() {
  |     printf("The quick brown fox
  |             jumps over
  |             the lazy dog.");
  |     return 0;
  | }
  `----

  文字列の終端なしに行の終わりになっているため、エラーが発生する。修正方
  法としては `\' を行末に置き、行継続していることを表現することでエラー
  を修正できる。

  ,----
  | printf("The quick brown fox\
  |         jumps over\
  |         the lazy dog.");
  `----
#+end_example

このようにテキストファイルとしてフォーマットされ、目次やタイトルが挿入され、地の文は適切に折り返した状態で出力されます。
編集時はエディタ側で折り返すけれどもエクスポート時はこのように特定の桁で改行を入れておく方がテキストファイルとしては適しています。

UTF-8でエクスポートした結果がこちらです。

#+begin_example
                  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
                   C言語入門01 - プログラミングの準備

                                 conao3
                  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


                               2025-12-02


Table of Contents
─────────────────

1. 演習問題回答
.. 1. 演習1-1
.. 2. 演習1-2
.. 3. 演習1-3


1 演習問題回答
══════════════

1.1 演習1-1
───────────

  ┌────
  │ 以下のプログラムをコンパイル・実行すると、どのような表示がされるか確認してください。
  │ 
  │ #include <stdio.h>
  │ 
  │ int main() {
  │     printf("2 * 8 = %d\n", 2 * 8);
  │     printf("36 = %d * %d\n", 3, 12);
  │     return 0;
  │ }
  └────

  回答

  ┌────
  │ 2 * 8 = 16
  │ 36 = 3 * 12
  └────
#+end_example

このようにUTF-8の文字が使われ、asciiのものと比べると少しリッチなフォーマットになりました。

最後にHTMLでのエクスポートを試してみましょう。 =C-c C-e= の後、 =h o= でHTMLファイルで書き出してブラウザで開くところまでを実行してくれます。

[[./resources/public/img/2e5a3654-004d-488b-adb9-01aba1bc9449.png]]

このようなスタイルのWebページを見たことはないでしょうか。もしかしたらそのページはorg-modeから書き出されたページかもしれません。

** 発展
ここまでの内容でも普通に便利にorg-modeを利用できていると言って過言ではないと思います。
ここからorg-modeの機能を少しずつ学んで行くことができるでしょう。

この日本語レポートが書けるようになった読者に次の一歩としておすすめなorgの機能は =babel= です。
babelはいわゆる「文芸的プログラミング」をサポートする機能で、「[[https://www.jstatsoft.org/article/view/v046i03][A Multi-Language Computing Environment for Literate Programming and Reproducible Research]]」で紹介 (というかorg-modeで論文あるのすごくないか) されているところの「Code Evaluation」にあたる機能です。

[[./resources/public/img/ba9bb4da-34e1-4303-8181-be1f085fdffc.png]]

この機能を使うことで文書内に任意のプログラミング言語のブロックを挿入し、エクスポート時に実行することで実際のエクスポートの内容を決定するということができるようになります。

例えば以下のように記述することでエクスポート時にC言語ソースのコンパイルから実行まで自動で行い、結果をその↓のコードブロックとして挿入するということが実現できます。

#+begin_src org
回答

,#+begin_src C :includes stdio.h :results output :exports results
printf("2 * 8 = %d\n", 2 * 8);
printf("36 = %d * %d\n", 3, 12);
,#+end_src
#+end_src

エクスポートもしくはこのコードブロックで =C-c C-c= を押すと実行され、結果がコードブロックとして埋め込まれた状態がこちらです。

#+begin_src org
,#+begin_src C :includes stdio.h :results output :exports results
printf("2 * 8 = %d\n", 2 * 8);
printf("36 = %d * %d\n", 3, 12);
,#+end_src

,#+RESULTS:
: 2 * 8 = 16
: 36 = 3 * 12
#+end_src

=:exports results= の指定をしてあるため、エクスポートした文書には結果のみが出力されます。
レポートの回答としては結果のみが求められていたのでこれで良いですね。

という感じで =babel= を導入するのはジャンプが少ないかなと思います。
論文の図に戻ると、右側の矢印はExportで既に扱っているため、残すは左の矢印のみです。
これは =tangle= と呼ばれ、このコードブロックを「抽出」してソースファイル化するというものです。

抽出したソースファイルの場所も当然のことながら指定できるため、つまりorg文書というドキュメントから複数のソースファイルを書き出せるという機能です。

tangleの利用例についてはたけてぃが最近は活発に記事を書いてくれているので興味があればぜひ。
https://www.google.com/search?q=tangle+site%253Ahttps%253A%252F%252Fwww.takeokunn.org

org-modeの機能は今回扱った文書としての使い方が大きなものではありますが、同じくらい大きな機能として本格的なGTD (Get Things Done) での利用に耐えうる程のタスク管理機能があります。
正直筆者もまだ使いこなせていないので手に馴染んだらまた紹介しようと思います。

** まとめ
org-modeから始めるEmacs入門を書きました。
個人的には私のEmacs入門のパスがこれなので、ずっと書きたかった記事です。
Emacsでいきなりコードを書き始めるのではなく、まずは日本語から書いてみてはどうかという趣旨です。

この記事を見てorg-modeに、そしてEmacsに入門してみようかなという人が一人でも増えてくれたらいいなと思います。

* COMMENT ClojureのIO, Stream回りの整理
:properties:
:export_file_name: generated/contents/blog/2025/68a957
:export_date: 2025-11-27
:end:

ClojureはJavaで動作するため、Javaとの相互運用のために便利な仕組みが用意されています。
特にIO回りはホスト言語に依存する要素が多いため専用のネームスペースである =clojure.java.io= も用意されています。

javaの概念とClojureの抽象化がどのように対応しているのか整理します。

なお、この記事においては直近の日本語ドキュメントがあるLTSの[[https://docs.oracle.com/javase/jp/21/index.html][JDK21]]を前提にします。

** JavaのIO
Javaには主要なIOのパッケージが2つあります。 =java.io= と =java.nio= です。
=java.io= は =java.nio= で置き換えられたということではなく、より高パフォーマンスで利便性の高いパッケージとして導入されています。

特にファイル操作に関しては =java.nio= を利用することで便利になりますが、IOについては =java.io= の範囲で十分です。

=java.io= の各クラスの継承関係は[[https://docs.oracle.com/javase/jp/21/docs/api/java.base/java/io/package-tree.html][javadoc]]で見ることができます。

重要クラスは =InputStream=, =OutputStream=, =Reader=, =Writer= です。
これだけに絞って抜き出すとこのような関係になっています。

- InputStream (Closeableを実装)
  - ByteArrayInputStream
  - FileInputStream
  - FilterInputStream
    - BufferedInputStream
    - DataInputStream (DataInputを実装)
    - LineNumberInputStream
    - PushbackInputStream
  - ObjectInputStream (ObjectInput、ObjectStreamConstantsを実装)
  - PipedInputStream
  - SequenceInputStream
  - StringBufferInputStream
- OutputStream (Closeable、Flushableを実装)
  - ByteArrayOutputStream
  - FileOutputStream
  - FilterOutputStream
    - BufferedOutputStream
    - DataOutputStream (DataOutputを実装)
    - PrintStream (java.lang.Appendable、Closeableを実装)
  - ObjectOutputStream (ObjectOutput、ObjectStreamConstantsを実装)
  - PipedOutputStream
- Reader (Closeable、java.lang.Readableを実装)
  - BufferedReader
    - LineNumberReader
  - CharArrayReader
  - FilterReader
    - PushbackReader
  - InputStreamReader
    - FileReader
  - PipedReader
  - lStringReader
- Writer (java.lang.Appendable、Closeable、Flushableを実装)
  - BufferedWriter
  - CharArrayWriter
  - FilterWriter
  - OutputStreamWriter
    - FileWriter
  - PipedWriter
  - PrintWriter
  - StringWriter

=InputStream= がバイト単位で入力できる基本のクラスで、 =Reader= はcharsetを設定して文字列として入力できるという関係になっています。

** java.ioを直接使う
Clojureのinteropを使って、java.ioを直接使ってみましょう。

以下のテキストを =sample.txt= として保存します。
#+begin_src text
あ
#+end_src

=sample.txt= を =java.io.FileInputStream= で読み込みます。

#+begin_src clojure
(import '[java.io FileInputStream])
;;=> java.io.FileInputStream

(def f (java.io/FileInputStream. "sample.txt"))
;;=> #'user/f

(.read f)
;;=> 227

(.read f)
;;=> 129

(.read f)
;;=> 130

(.read f)
;;=> 10

(.read f)
;;=> -1

(.close f)
;;=> nil
#+end_src

このようにバイト単位で読み込み、読み込めるデータがないときは =read()= は =-1= を返却します。
使い終わったら =close()= を呼んで閉じておきましょう。

=FileReader= はReaderのため、charsetを考慮できます。
charsetを渡さない場合は =java.nio.charset.Charset/defaultCharset()= で返却される値が利用されます。

#+begin_src clojure
(do (import '[java.io FileInputStream FileReader])
    (import '[java.nio.charset Charset]))

(java.nio.charset.Charset/defaultCharset)
#object[sun.nio.cs.UTF_8 0xd9f1005 "UTF-8"]

(def f (java.io/FileReader. "sample.txt"))
;;=> #'user/f

(def f (java.io/FileReader. "sample.txt" (java.nio.charset.Charset/forName "UTF-8")))
;;=> #'user/f

(.read f)
;;=> 12354

(.read f)
;;=> 10

(.read f)
;;=> -1

(.close f)
;;=> nil
#+end_src

* COMMENT ClaudeCodeのブラウザフロントエンドを作る
:properties:
:export_file_name: generated/contents/blog/2025/1488a7
:export_date: 2025-12-03
:end:

ClaudeCode

* Nixpkgsでのアップデート作業
:properties:
:export_file_name: generated/contents/blog/2025/b1a436
:export_date: 2025-12-14
:end:

nixpkgsに登録されているclj-kondoが少し古いバージョンだった。
nixpkgsを更新するために調べたのでメモ。

** 結論
[[https://github.com/Mic92/nix-update][nix-update]] を使えば良い。
特にグローバルに入れる必要もなく、nix runから直接起動すると良い。

#+begin_src sh
nix run nixpkgs#nix-update -- clj-kondo --build --commit
#+end_src

** Tips
おそらくこのツールで作られたPRが [[https://github.com/NixOS/nixpkgs/pull/455542][NixOS/nixpkgs#455542]] 。
このPRがnixpkgsの各ブランチにshipされたかどうかを追跡する以下のような便利サイトがある。

- https://nixpk.gs/pr-tracker.html?pr=455542
- https://nixpkgs-tracker.ocfox.me/?pr=455542
